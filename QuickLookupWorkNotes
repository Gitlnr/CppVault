1)Whats Framework and my role using it
| Term                                          | Meaning                                                                        |
| --------------------------------------------- | ------------------------------------------------------------------------------ |
| **Framework development**                     | Creating a reusable foundation or library for others to build applications on. |
| **Application development using a framework** | Using an existing framework (like VCL/MFC) to make a specific product or tool. |

You are doing the **second one** âœ… â€” developing *applications using existing frameworks*, not *creating a new framework*.
### âš™ï¸ Example (optional)
> â€œFor example, I used the VCL framework to design the main GUI screen of our control software, 
   connect UI buttons to C++ functions, and communicate with external devices via LAN.â€
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

2)Scrum Vs Agile Vs Waterfall
* **Scrum** = a **team-based working style** inside **Agile development**.
* **Agile** = a **flexible way** of developing software in **small steps**, instead of doing everything at once like in â€œWaterfallâ€.
* In Agile/Scrum, work is divided into **short cycles (called Sprints)** â€” usually 2 or 3 weeks.
* Each Sprint delivers a **small working feature** that can be tested or shown.

### ðŸ‘¥ Scrum Roles
* **Product Owner** â†’ decides what features to build.
* **Scrum Master** â†’ manages process and removes obstacles.
* **Developers / Engineers** â†’ actually code and test.

### âš™ï¸ Example
Imagine you are developing a **laser marking control app**.

Instead of planning 6 months for the whole app,
you plan **2-week Sprints** like this:

| Sprint   | Goal                                           |
| -------- | ---------------------------------------------- |
| Sprint 1 | Make the UI screen open and connect to printer |
| Sprint 2 | Add function to send marking data              |
| Sprint 3 | Add log output and error handling              |

After each Sprint â†’ you **review, test, and adjust plans** for the next one.

### ðŸ In short
> â€œYouâ€™ll be added to a Scrum teamâ€ means youâ€™ll work in **a small Agile team**, building software 
**step by step in short cycles**, continuously improving based on feedback.

### ðŸŒ€ **Agile / Scrum**
* Work is done in **short cycles (Sprints)**, with frequent updates and feedback.
* **Tool:** usually **JIRA** (by Atlassian).

  * JIRA helps manage **tasks, sprints, and progress** visually on boards.
  * Similar tool: **Redmine**, also used for Agile but simpler and open-source.
  * âœ… *JIRA = more modern, widely used globally*
  * âš™ï¸ *Redmine = lighter, used in some Japanese companies*

### ðŸ’§ **Waterfall**
* Work is done **step by step in fixed order**:
  â‘  Requirement â†’ â‘¡ Design â†’ â‘¢ Coding â†’ â‘£ Testing â†’ â‘¤ Release
* Once one phase is finished, you **donâ€™t go back** easily.
* Good for projects where **requirements never change** (e.g., hardware).

### âš–ï¸ Summary Table
| Method            | Style                   | Tool           | Feedback timing |
| ----------------- | ----------------------- | -------------- | --------------- |
| **Agile / Scrum** | Iterative (small steps) | JIRA / Redmine | Continuous      |
| **Waterfall**     | Sequential (one-way)    | Excel / Docs   | At the end      |

**In short:**
> Agile (Scrum) = flexible, uses tools like **JIRA**
> Waterfall = fixed steps, slower feedback
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

3)When designing software, the most important things are:

1. **Scalability** â€“ the design should handle future growth without major rework.
2. **Maintainability** â€“ the code should be easy to understand, modify, and extend.
3. **Reliability** â€“ the system must work consistently with minimal failures.
4. **Modularity** â€“ clear separation of components to reduce coupling and increase flexibility.
5. **Performance** â€“ the design should ensure efficient resource usage and response time.
6. **Simplicity** â€“ avoid unnecessary complexity; keep the design clean and logical.
7. **Testability** â€“ the design must allow easy unit and integration testing.

Super concise answer (if interviewer wants very short):
Scalability, maintainability, reliability, modularity, and simplicity.
