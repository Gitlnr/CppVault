* ‚úÖ **Pointer (`p`)** ‚Üí can be **reassigned** to point to another variable (its stored address can change).
* ‚úÖ **Reference (`r`)** ‚Üí is an **alias**; once bound to a variable, it **cannot be changed** to refer to another one.

Example:
int a = 10, b = 20;
int* p = &a;  // p points to a
p = &b;       // ‚úÖ now p points to b

int& r = a;   // r refers to a
// r = b; ‚ùå assigns value of b to a, doesn‚Äôt rebind r
```
So ‚Äúp can change‚Äù means **the address stored in p can change** ‚Äî
but a **reference always remains bound** to the same variable.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

***Stack memory** ‚Üí used for **local variables** inside functions.
  * The system **automatically allocates and frees** it when the function starts and ends.
  * It‚Äôs **fast**, but **limited in size**.
  * Example:

    ```cpp
    void func() {
        int x = 10;  // stored on stack
    } // x is automatically destroyed here
    ```

* **Heap memory** ‚Üí used for **dynamic allocation** (via `new` or `malloc`).
  * You must **manually release** it using `delete` or `free`.
  * It‚Äôs **slower**, but you can allocate **large or variable-sized data**.
  * Example:

    ```cpp
    int* p = new int(10); // allocated on heap
    delete p;             // must free manually
    ```

üëâ In short:
**Stack = fast, automatic, limited.**
**Heap = flexible, manual, slower.**

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### The statement:
> "Deleting derived via base pointer without virtual destructor causes undefined behavior."
#### 1. **Context**
Suppose you have a **base class** and a **derived class**:
```cpp
class Base {
public:
    ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};
```

Now, imagine this code:

```cpp
Base* ptr = new Derived();
delete ptr; // ‚ö†Ô∏è Problem!
```

#### 2. **What happens here?**

* `ptr` is a pointer to `Base`, but it actually points to a `Derived` object.
* When you call `delete ptr`, C++ looks at the **type of the pointer**, not the actual object type (unless the destructor is `virtual`).
* Here, the destructor of `Base` runs, but the destructor of `Derived` **does not run**.
* If `Derived` allocates resources (like `new` memory, file handles, etc.), they **won‚Äôt be freed**, causing **resource leaks or undefined behavior**.

#### 3. **Virtual destructor solves this**

If you declare the base destructor as `virtual`:

```cpp
class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor\n";
    }
};

* Now `delete ptr;` **will call Derived's destructor first**, then Base‚Äôs destructor.
* Everything gets cleaned up properly.

#### 4. **Key Takeaways**

1. **Rule of Thumb:** If a class is meant to be a base class, **always give it a virtual destructor**.
2. **Undefined Behavior:** Deleting a derived object through a non-virtual base pointer can crash your program, leak memory, or behave unpredictably.
3. **When safe:** If you never delete derived objects via a base pointer, a non-virtual destructor is fine.

‚úÖ Example with `virtual`:
```cpp
class Base {
public:
    virtual ~Base() { std::cout << "Base destroyed\n"; }
};

class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived destroyed\n"; }
};

int main() {
    Base* obj = new Derived();
    delete obj; // Calls Derived destructor then Base destructor safely
}

Output:
Derived destroyed
Base destroyed
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. Overloading (Compile-time / Static Polymorphism)**
**Definition:**
Overloading happens when you have **functions with the same name** but **different parameter lists** (different number or types of arguments) **in the same scope**. 
The compiler decides which function to call based on the arguments you pass.

**Example:**
```cpp
#include <iostream>
using namespace std;

class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded function
};

int main() {
    Math m;
    cout << m.add(2, 3) << endl;      // Calls int version
    cout << m.add(2.5, 3.5) << endl;  // Calls double version
}

‚úÖ Key points:
* Same function name.
* Different parameter types or numbers.
* Decided **at compile-time**.

### **2. Overriding (Runtime / Dynamic Polymorphism)**
**Definition:**
Overriding happens when a **derived class provides a new implementation** of a **virtual function** defined in its base class. 
The compiler uses the **actual object type at runtime** to decide which function to call.

**Example:**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { cout << "Base show" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived show" << endl; } // Overrides Base
};

int main() {
    Base* b = new Derived();
    b->show();  // Calls Derived's show because of virtual function
}

‚úÖ Key points:
* Must have the same function signature.
* Base function must be `virtual`.
* Decided **at runtime** (dynamic dispatch).
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. Shallow Copy**
**Definition:**
A **shallow copy** copies **only the values of the member variables**.

* If a member is a **pointer**, it copies the pointer itself, **not the data it points to**.
* This means **both objects point to the same memory**.

**Problem:**
* If one object deletes/frees the memory, the other object‚Äôs pointer becomes **dangling**.
* Leads to **shared memory issues**, crashes, or undefined behavior.

**Example:**

```cpp
#include <iostream>
using namespace std;

class Shallow {
public:
    int* data;
    Shallow(int value) {
        data = new int(value);
    }
    ~Shallow() {
        delete data;
    }
};

int main() {
    Shallow obj1(10);
    Shallow obj2 = obj1;  // Shallow copy (default copy constructor)
    
    cout << *obj1.data << " " << *obj2.data << endl; // Both point to same memory

    obj2.data = new int(20); // Modifying obj2
    cout << *obj1.data << endl; // Could be unexpected if obj2 deleted memory
}
```

* Default copy constructor **does a shallow copy**.
* Both `obj1` and `obj2` share the same memory initially.

### **2. Deep Copy**
**Definition:**
A **deep copy** copies **the actual data** the pointer is pointing to, not just the pointer.
* Each object has its **own separate copy of the data**.
* Changes in one object **don‚Äôt affect** the other.

**Example:**

```cpp
#include <iostream>
using namespace std;

class Deep {
public:
    int* data;
    Deep(int value) {
        data = new int(value);
    }
    // Custom copy constructor for deep copy
    Deep(const Deep& other) {
        data = new int(*other.data); // Allocate new memory and copy value
    }
    ~Deep() {
        delete data;
    }
};

int main() {
    Deep obj1(10);
    Deep obj2 = obj1;  // Deep copy

    *obj2.data = 20;   // Modifying obj2 does NOT affect obj1
    cout << *obj1.data << " " << *obj2.data << endl; // 10 20
}

‚úÖ Key points:
* Deep copy is **safer** when using dynamic memory.
* You usually implement it by writing a **custom copy constructor** (and assignment operator if needed).

üí° Analogy:
Shallow copy ‚Üí Two people sharing the same notebook.
Deep copy ‚Üí Two people having their own copies of the notebook.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. What is a Constructor Initializer List?**
When you write a constructor like this:

```cpp
class A {
    int x;
public:
    A(int v) : x(v) {   // ‚Üê initializer list
        // constructor body
    }
};

That `: x(v)` part is called the **constructor initializer list**.
It means:
‚û°Ô∏è ‚ÄúBefore entering the constructor‚Äôs body, initialize member `x` with the value `v`.‚Äù

### **3. When it‚Äôs REQUIRED**
You *must* use an initializer list when:
* The class has a `const` member.
* The class has a reference (`&`) member.
* The class has a base class that requires parameters for its constructor.

**Example:**
```cpp
class A {
    const int x;
    int& ref;
public:
    A(int v, int& r) : x(v), ref(r) {} // Must use initializer list
};

If you try to assign inside the body instead, it won‚Äôt compile!
### **5. Example with Base Class**
```cpp
class Base {
public:
    Base(int a) { cout << "Base: " << a << endl; }
};

class Derived : public Base {
    int b;
public:
    Derived(int x, int y) : Base(x), b(y) {  // Call base constructor first
        cout << "Derived: " << b << endl;
    }
};

Output:
Base: 5
Derived: 10

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Polymorphism ‚Äî ‚ÄúMany Forms‚Äù**
**Meaning:**
Polymorphism allows **one interface (a base pointer/reference)** to represent **different actual types (derived objects)**, and to call the **right function automatically at runtime**.

### **1. Without Polymorphism (static binding)**

Let‚Äôs start simple:
```cpp
class Shape {
public:
    void draw() { cout << "Drawing Shape\n"; }
};

class Circle : public Shape {
public:
    void draw() { cout << "Drawing Circle\n"; }
};

int main() {
    Shape* s = new Circle();
    s->draw();   // ‚ùå Calls Shape::draw(), not Circle::draw()
}
```

Why?
Because by default, C++ looks at the **type of the pointer (`Shape*`)** ‚Äî not what it actually points to (`Circle`).
This is called **static binding** (decided at compile time).

### **2. With Polymorphism (dynamic binding)**

Now, make the base function **virtual** üëá

```cpp
class Shape {
public:
    virtual void draw() { cout << "Drawing Shape\n"; }
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
};

int main() {
    Shape* s = new Circle();
    s->draw();   // ‚úÖ Calls Circle::draw()
}

Now, `draw()` is **virtual**, so C++ looks at the **actual object type (Circle)** at runtime ‚Äî not just the pointer type.
This is called **dynamic dispatch** or **runtime polymorphism**.


### **3. Why it‚Äôs useful**
It lets you write **generic code** that works with different derived classes:

```cpp
void render(Shape* s) {
    s->draw();  // Calls the correct version automatically
}

```cpp
Circle c;
Square sq;
render(&c);   // ‚Üí Drawing Circle
render(&sq);  // ‚Üí Drawing Square

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Pure Virtual Function**

### **Definition:**

A **pure virtual function** is a virtual function that has **no implementation in the base class** ‚Äî it only defines the **interface (what should be done)**, not **how it‚Äôs done**.

You declare it by assigning `= 0` in the base class:

```cpp
class A {
public:
    virtual void f() = 0;  // Pure virtual function
};
```

This tells the compiler:

> ‚ÄúAny derived class **must** override `f()` ‚Äî I‚Äôm not providing an implementation here.‚Äù

## üß± **1. Abstract Class**

A class that has **at least one pure virtual function** becomes an **abstract class**.

```cpp
class A {
public:
    virtual void f() = 0; // pure virtual
};
You **cannot** create objects of an abstract class:

```cpp
A a;       // ‚ùå Error: cannot instantiate abstract class
A* ptr;    // ‚úÖ pointer is fine
```

You can only **derive from it** and implement the missing function.

## üß© **2. Derived Class Implements It**
```cpp
class A {
public:
    virtual void f() = 0; // pure virtual
};

class B : public A {
public:
    void f() override { cout << "Implemented in B\n"; }
};

int main() {
    B b;
    A* ptr = &b;
    ptr->f();  // ‚úÖ Calls B's version
}

Output:
Implemented in B

Now class `B` is **concrete** because it implements all pure virtual functions from `A`.

## üîç **3. Why use it?**

To create a **common interface** (like an abstract ‚Äúblueprint‚Äù) for derived classes.

Example:

```cpp
class Shape {
public:
    virtual void draw() = 0;     // Must be defined by derived
    virtual double area() = 0;   // Must be defined by derived
};
```

Derived classes must implement both:

```cpp
class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
    double area() override { return 3.14 * r * r; }
private:
    double r = 5;
};

Now `Shape` defines **what** shapes can do (`draw()`, `area()`),
and `Circle`, `Rectangle`, etc. define **how** they do it.


‚úÖ **In short:**
> A pure virtual function is a virtual function declared with `=0`, making the class abstract and forcing derived classes to implement it.
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **malloc/free vs new/delete**

Both are used to **allocate and free memory**,
but they behave **very differently** in C++.

### **1. malloc / free**  ‚Üí from **C language**
```cpp
int* p = (int*) malloc(sizeof(int));  // allocates raw memory
*p = 10;
free(p);                              // frees memory


* ‚úÖ Allocates **raw bytes** of memory.
* ‚ùå Does **NOT** call constructors or destructors.
* ‚ùå Doesn‚Äôt know about object types ‚Äî just bytes.
* ‚úÖ Must be matched with `free()`.
* ‚ö†Ô∏è Must use **manual casting** (because malloc returns `void*`).

Think of it as **low-level memory allocation** ‚Äî you just get a ‚Äúchunk‚Äù of memory.

### **2. new / delete**  ‚Üí from **C++**

```cpp
int* p = new int(10);  // allocate + initialize
delete p;              // destroy + free
```

* ‚úÖ Allocates memory **and calls the constructor**.
* ‚úÖ `delete` calls the **destructor** and then frees memory.
* ‚úÖ Type-safe ‚Äî returns the correct pointer type (no cast).
* ‚úÖ Cleaner, safer syntax.

---

### **3. For Objects**

Let‚Äôs see the real difference:

```cpp
class A {
public:
    A() { cout << "Constructor called\n"; }
    ~A() { cout << "Destructor called\n"; }
};

int main() {
    A* p1 = (A*) malloc(sizeof(A));  // no constructor
    free(p1);                        // no destructor

    A* p2 = new A();                 // constructor called
    delete p2;                       // destructor called
}
```

**Output:**
Constructor called
Destructor called

‚Üí The `malloc/free` pair never calls these functions ‚Äî so `A` is never ‚Äúfully constructed‚Äù or ‚Äúproperly destroyed.‚Äù

That can cause leaks or undefined behavior for complex classes.

### **4. Arrays**
| Operation   | For single object                  | For arrays |
| ----------- | ---------------------------------- | ---------- |
| Allocate    | `new A`                            | `new A[n]` |
| Free        | `delete`                           | `delete[]` |
| malloc/free | same for both ‚Äî no array awareness |            |

```cpp
A* arr = new A[5];  // calls constructor 5 times
delete[] arr;       // calls destructor 5 times

With `malloc/free`, none of that happens ‚Äî you just get bytes.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Struct vs Class in C++**
In C++, `struct` and `class` are **almost identical** ‚Äî the **only real difference** is their **default access levels**.
### **1. Default Access Levels**

| Member Type  | In `struct`                       | In `class`                         |
| ------------ | --------------------------------- | ---------------------------------- |
| Data members | **public** by default             | **private** by default             |
| Base classes | **public** inheritance by default | **private** inheritance by default |

```cpp
struct S {
    int x;          // public by default
};

class C {
    int x;          // private by default
};

So:
```cpp
S s;
s.x = 5;   // ‚úÖ OK (public)

C c;
c.x = 5;   // ‚ùå Error (private)

### **2. Otherwise, They‚Äôre the Same**
Both can have:
* Constructors, destructors
* Member functions
* Inheritance
* Virtual functions
* Operator overloading
* Access specifiers (`public`, `private`, `protected`)

Example:
```cpp
struct Point {
    int x, y;
    void show() { cout << x << ", " << y << endl; }
};
is functionally the same as:

```cpp
class Point {
public:
    int x, y;
    void show() { cout << x << ", " << y << endl; }
};

‚úÖ **In short:**
> In C++, `struct` and `class` are the same except:
> * `struct` members are **public by default**
> * `class` members are **private by default**

Even though a `struct` defaults to `public`, you can still explicitly use `private:` (or `protected:`) sections ‚Äî just like in a `class`.
### **Example:**

```cpp
#include <iostream>
using namespace std;

struct Person {
private:
    string name;  // private member

public:
    int age;      // public member

    void setName(string n) { name = n; }
    void show() { cout << name << " (" << age << ")\n"; }
};

int main() {
    Person p;
    p.age = 25;           // ‚úÖ allowed (public)
    // p.name = "John";   // ‚ùå not allowed (private)
    p.setName("John");    // ‚úÖ allowed (access through public function)
    p.show();
}

**Output:**
John (25)

### üß† Key Idea

Even though:

```cpp
struct Person { ... };
```

defaults to **public**,
you can still **control access** inside it using:

```cpp
private:
protected:
public:

Just like in a class!

### **In short:**

> ‚úÖ You can use `private:` and `protected:` inside a `struct`.
> The only difference from `class` is the **default** ‚Äî not the **capabilities**.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Exception Handling in C++**
### **1. The Basic Idea**

Exception handling lets you **detect errors (exceptions)** and **respond** to them **without crashing the program**.
It uses **three keywords**:
* `try` ‚Üí Code that might throw an error
* `throw` ‚Üí Signal (raise) the error
* `catch` ‚Üí Handle (catch) the error

### **2. Example Explained**
```cpp
#include <iostream>
#include <stdexcept>  // for runtime_error
using namespace std;

int main() {
    try {
        throw runtime_error("Err");  // üî• throw an exception
    } 
    catch (exception& e) {           // üßØ catch it
        cout << e.what();            // print what() message
    }
}

**Output:**
Err
### **3. Step-by-Step Breakdown**

| Step                          | What happens                                                                                         |
| ----------------------------- | ---------------------------------------------------------------------------------------------------- |
| `try { ... }`                 | You wrap code that might fail.                                                                       |
| `throw runtime_error("Err");` | You *throw* an exception object. This immediately stops normal flow and jumps to a matching `catch`. |
| `catch (exception& e)`        | The program finds this handler (since `runtime_error` is a kind of `exception`).                     |
| `e.what()`                    | Returns the error message (`"Err"`).                                                                 |

### **4. Common Exception Types (in `<stdexcept>`)**

| Exception type          | Meaning                               |
| ----------------------- | ------------------------------------- |
| `std::runtime_error`    | Error at runtime (like invalid state) |
| `std::logic_error`      | Error in program logic                |
| `std::out_of_range`     | Index out of range                    |
| `std::invalid_argument` | Bad function argument                 |
| `std::bad_alloc`        | Memory allocation failed              |

### **5. Multiple Catch Blocks**
You can handle different types differently:
```cpp
try {
    throw out_of_range("Index too big");
}
catch (out_of_range& e) {
    cout << "Range error: " << e.what();
}
catch (exception& e) {
    cout << "General error: " << e.what();
}

### **6. `catch(...)` for Anything**
You can also catch **any** type of exception:
```cpp
try {
    throw 123;  // could be anything
}
catch (...) {
    cout << "Caught something!\n";
}

### **7. Key Takeaways**
| Keyword    | Meaning                          |
| ---------- | -------------------------------- |
| `try`      | Wrap risky code                  |
| `throw`    | Raise an exception               |
| `catch`    | Handle an exception              |
| `e.what()` | Returns message inside exception |

üí° **In short:**
> `try` runs code that may fail ‚Üí
> `throw` raises an error ‚Üí
> `catch` handles it safely.

Perfect üëç ‚Äî let‚Äôs look at a **realistic example** of C++ exception handling with **`std::string`** or **string-related operations**.
## üß© **Example 1: String Index Out of Range**
```cpp
#include <iostream>
#include <string>
#include <stdexcept>  // for out_of_range
using namespace std;

int main() {
    string str = "hello";

    try {
        cout << "Character: " << str.at(10) << endl;  // out of range //`str.at(10)` means **‚Äúgive me the character at index 10 of the string `str`.‚Äù*
                    //Since `str = "hello"` has only 5 characters (`indexes 0‚Äì4`), index `10` is **out of range**, so it **throws an exception** (`std::out_of_range`)
    } 
    catch (out_of_range& e) {
        cout << "Caught exception: " << e.what() << endl;
    }

    cout << "Program continues normally.\n";
}

### **Output:**
Caught exception: basic_string::at: __n (which is 10) >= this->size() (which is 5)
Program continues normally.

## üß© **Example 2: Converting String to Integer**
Sometimes invalid input can cause an exception.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string input = "abc"; // not a valid number
    try {
        int num = stoi(input); // will throw invalid_argument
        cout << "Number: " << num << endl;
    } 
    catch (invalid_argument& e) {
        cout << "Invalid input: " << e.what() << endl;
    } 
    catch (out_of_range& e) {
        cout << "Number too large: " << e.what() << endl;
    }

    cout << "Program still running fine!\n";
}

### **Output:**
Invalid input: stoi
Program still running fine!

## üß© **Example 3: Throwing Your Own Exception**
You can also create your own checks and throw manually:
```cpp
#include <iostream>
#include <stdexcept>
#include <string>
using namespace std;

double divide(int a, int b) {
    if (b == 0)
        throw runtime_error("Division by zero!"); // manually throw
    return static_cast<double>(a) / b;
}

int main() {
    try {
        cout << divide(10, 0) << endl;
    } 
    catch (runtime_error& e) {
        cout << "Error: " << e.what() << endl;
    }
}

### **Output:**
Error: Division by zero!

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Smart Pointers ‚Äî Automatic Memory Management**

In old C++, you had to manually manage memory with `new` and `delete`:
```cpp
int* p = new int(5);
delete p;  // if you forget this ‚Üí memory leak!
```
‚úÖ **Smart pointers** solve this by **automatically deleting memory** when it‚Äôs no longer needed.
They live in the `<memory>` header.

## üí° **1. `unique_ptr` (Exclusive ownership)**
Only **one smart pointer** can own a resource at a time.

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> p1 = make_unique<int>(10);
    cout << *p1 << endl; // 10

    // unique_ptr<int> p2 = p1; ‚ùå Error ‚Äî cannot copy (only one owner)
    unique_ptr<int> p2 = move(p1); // ‚úÖ ownership transferred

    if (!p1) cout << "p1 is now empty\n";
}

**Output:**
10
p1 is now empty

‚úÖ Automatically frees memory when `p2` goes out of scope.
‚Üí Great for ownership ‚Äî no accidental copies, no leaks.

## üí° **2. `shared_ptr` (Shared ownership)**
Multiple pointers can share the same object.
The object is deleted **only when the last one is destroyed.**

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> p1 = make_shared<int>(42);
    shared_ptr<int> p2 = p1;  // share ownership

    cout << *p1 << ", " << *p2 << endl;
    cout << "Count: " << p1.use_count() << endl; // how many share it
}
**Output:**
42, 42
Count: 2

‚úÖ Automatically deletes memory when count ‚Üí 0.
‚Üí Great for shared resources.

## üí° **3. `weak_ptr` (Non-owning reference)**

Used with `shared_ptr` to **avoid circular references**.
It does **not** increase the reference count. only act as an observer

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> p1 = make_shared<int>(100);
    weak_ptr<int> wp = p1; // weak reference

    cout << "Count: " << p1.use_count() << endl; // 1

    if (auto sp = wp.lock()) // try to get shared_ptr
        cout << *sp << endl; // 100
}

‚úÖ Doesn‚Äôt keep the object alive ‚Äî safe to check if it still exists.

## üí° **In short:**
> üîπ `unique_ptr` ‚Üí One owner.
> üîπ `shared_ptr` ‚Üí Many owners.
> üîπ `weak_ptr` ‚Üí Observes shared object without owning it.
>
> All of them **automatically free memory**, preventing leaks.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Multithreading Basics in C++11**
**Multithreading** allows your program to run **multiple functions at the same time** (concurrently) using CPU cores efficiently.
### **1. Creating a Thread**

```cpp
#include <iostream>
#include <thread>
using namespace std;

void work() {
    cout << "Hello from thread!" << endl;
}

int main() {
    thread t(work); // create a thread that runs 'work' concurrently
    t.join();       // wait for thread to finish
    cout << "Main thread done!" << endl;
}

**Output:**
Hello from thread!
Main thread done!

‚úÖ `thread t(work);` ‚Üí starts a **new thread** running the function `work`.
‚úÖ `t.join();` ‚Üí main thread waits for this thread to finish.


### **2. Key Points**
| Keyword      | Meaning                                       |
| ------------ | --------------------------------------------- |
| `thread`     | Class representing a thread of execution      |
| `t.join()`   | Waits for the thread to finish (blocking)     |
| `t.detach()` | Let thread run independently (no join needed) |

### **3. Passing Arguments**
```cpp
void printNumber(int x) {
    cout << "Number: " << x << endl;
}

int main() {
    thread t(printNumber, 42); // pass argument to thread function
    t.join();
}
Output:
Number: 42

### **4. Simple Analogy**

* Main thread = your program‚Äôs main ‚Äúperson‚Äù.
* New thread = an assistant doing some work **at the same time**.
* `join()` = wait for the assistant to finish before moving on.

### ‚úÖ **In short:**
> `thread t(work);` ‚Üí runs `work()` **concurrently**.
> `t.join();` ‚Üí waits for the thread to finish before continuing.

## **1. Thread Basics (you already know)**
* `std::thread` ‚Äî create a thread.
* `t.join()` vs `t.detach()`.
* Passing arguments to threads (`thread t(func, arg1, arg2);`).

## **2. Shared Data & Synchronization**
### **Problem**
Multiple threads modifying the same variable can cause **data races**, which is undefined behavior.

```cpp
#include <iostream>
#include <thread>

int counter = 0;

void increment() {
    for(int i = 0; i < 1000; ++i) counter++;
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << counter << "\n";  // Usually not 2000! ‚ùå
}
```

‚úÖ **Why?** Threads can read/write simultaneously ‚Üí race condition.

---

### **Solution: `std::mutex`**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
mutex mtx;

void increment() {
    for(int i = 0; i < 1000; ++i) {
        lock_guard<mutex> lock(mtx); // automatically locks/unlocks
        counter++;
    }
}

int main() {
    thread t1(increment);
    thread t2(increment);
    t1.join();
    t2.join();
    cout << counter << endl; // ‚úÖ always 2000
}

* `mutex` = mutual exclusion, prevents simultaneous access.
* `lock_guard` = RAII style lock (preferred).

## **3. Atomic Variables**
For simple counters, `std::atomic` can be faster than a mutex:

```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<int> counter(0);

void increment() {
    for(int i=0; i<1000; ++i) counter++;
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << counter << std::endl; // ‚úÖ always 2000
}

## **4. Condition Variables**
Used for **thread coordination** (producer-consumer style).

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
using namespace std;

queue<int> q;
mutex mtx;
condition_variable cv;

void producer() {
    for(int i=1;i<=5;i++){
        unique_lock<mutex> lock(mtx);
        q.push(i);
        cv.notify_one(); // wake up consumer
    }
}

void consumer() {
    for(int i=1;i<=5;i++){
        unique_lock<mutex> lock(mtx);
       // cv.wait(lock, []{ return !q.empty(); }); // wait until producer adds something
       while (q.empty()){
          cv.wait(lock);
       }
        cout << "Consumed: " << q.front() << endl;
        q.pop();
    }
}

int main() {
    thread t1(producer), t2(consumer);
    t1.join();
    t2.join();
}

## **5. Strings and Thread Safety**

* **`std::string` is NOT thread-safe** for simultaneous writes.
* Reading a string from multiple threads is safe **if nobody modifies it**.
* Use `mutex` if multiple threads might modify the same string.

```cpp
#include <string>
#include <mutex>
#include <thread>
#include <iostream>

std::string data = "Hello";
std::mutex mtx;

void appendData() {
    lock_guard<std::mutex> lock(mtx);
    data += " World";
}

int main() {
    std::thread t1(appendData);
    std::thread t2(appendData);
    t1.join();
    t2.join();
    std::cout << data << std::endl;
}

Use lock_guard when you just need to protect a critical section.
Use unique_lock when you need more control (e.g. with condition_variable).

