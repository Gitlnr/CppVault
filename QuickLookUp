* ‚úÖ **Pointer (`p`)** ‚Üí can be **reassigned** to point to another variable (its stored address can change).
* ‚úÖ **Reference (`r`)** ‚Üí is an **alias**; once bound to a variable, it **cannot be changed** to refer to another variables address.

Example:
int a = 10, b = 20;
int* p = &a;  // p points to a
p = &b;       // ‚úÖ now p points to b

int& r = a;   // r refers to a
// r = b; ‚ùå assigns value of b to a, doesn‚Äôt rebind r

üîπ Pointer (p)
A pointer stores the memory address of another variable.
You can reassign it to point to different variables at any time.
To access or change the value it points to, you use the * (dereference) operator.
It can also be nullptr (point to nothing).

int a = 10, b = 20;
int* p = &a;   // p points to a
p = &b;        // now p points to b (address changed)

üîπ Reference (r)
A reference is just an alias (another name) for an existing variable.
Once initialized, it cannot be made to refer to another variable.
You use it like a normal variable‚Äîno need for * or &.

int c = 30, d = 40;
int& r = c;   // r refers to c
r = d;        // assigns the value of d to c (not a rebinding!)


After r = d;,
r still refers to c
c now becomes 40 (because you assigned d‚Äôs value to it)

So ‚Äúp can change‚Äù means **the address stored in p can change** ‚Äî
but a **reference always remains bound** to the same variable address.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

***Stack memory** ‚Üí used for **local variables** inside functions.
  * The system **automatically allocates and frees** it when the function starts and ends.
  * It‚Äôs **fast**, but **limited in size**.
  * Example:

    ```cpp
    void func() {
        int x = 10;  // stored on stack
    } // x is automatically destroyed here
    ```

* **Heap memory** ‚Üí used for **dynamic allocation** (via `new` or `malloc`).
  * You must **manually release** it using `delete` or `free`.
  * It‚Äôs **slower**, but you can allocate **large or variable-sized data**.
  * Example:

    ```cpp
    int* p = new int(10); // allocated on heap
    delete p;             // must free manually
    ```

üëâ In short:
**Stack = fast, automatic, limited.**
**Heap = flexible, manual, slower.**

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### The statement:
> "Deleting derived via base pointer without virtual destructor causes undefined behavior."
#### 1. **Context**
Suppose you have a **base class** and a **derived class**:
```cpp
class Base {
public:
    ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};
```

Now, imagine this code:

```cpp
Base* ptr = new Derived();
delete ptr; // ‚ö†Ô∏è Problem!
```

#### 2. **What happens here?**

* `ptr` is a pointer to `Base`, but it actually points to a `Derived` object.
* When you call `delete ptr`, C++ looks at the **type of the pointer**, not the actual object type (unless the destructor is `virtual`).
* Here, the destructor of `Base` runs, but the destructor of `Derived` **does not run**.
* If `Derived` allocates resources (like `new` memory, file handles, etc.), they **won‚Äôt be freed**, causing **resource leaks or undefined behavior**.

#### 3. **Virtual destructor solves this**

If you declare the base destructor as `virtual`:

```cpp
class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor\n";
    }
};

* Now `delete ptr;` **will call Derived's destructor first**, then Base‚Äôs destructor.
* Everything gets cleaned up properly.

#### 4. **Key Takeaways**

1. **Rule of Thumb:** If a class is meant to be a base class, **always give it a virtual destructor**.
2. **Undefined Behavior:** Deleting a derived object through a non-virtual base pointer can crash your program, leak memory, or behave unpredictably.
3. **When safe:** If you never delete derived objects via a base pointer, a non-virtual destructor is fine.

‚úÖ Example with `virtual`:
```cpp
class Base {
public:
    virtual ~Base() { std::cout << "Base destroyed\n"; }
};

class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived destroyed\n"; }
};

int main() {
    Base* obj = new Derived();
    delete obj; // Calls Derived destructor then Base destructor safely
}

Output:
Derived destroyed
Base destroyed
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. Overloading (Compile-time / Static Polymorphism)**
**Definition:**
Overloading happens when you have **functions with the same name** but **different parameter lists** (different number or types of arguments) **in the same scope**. 
The compiler decides which function to call based on the arguments you pass.

**Example:**
```cpp
#include <iostream>
using namespace std;

class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded function
};

int main() {
    Math m;
    cout << m.add(2, 3) << endl;      // Calls int version
    cout << m.add(2.5, 3.5) << endl;  // Calls double version
}

‚úÖ Key points:
* Same function name.
* Different parameter types or numbers.
* Decided **at compile-time**.

### **2. Overriding (Runtime / Dynamic Polymorphism)**
**Definition:**
Overriding happens when a **derived class provides a new implementation** of a **virtual function** defined in its base class. 
The compiler uses the **actual object type at runtime** to decide which function to call.

**Example:**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { cout << "Base show" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived show" << endl; } // Overrides Base
};

int main() {
    Base* b = new Derived();
    b->show();  // Calls Derived's show because of virtual function
}

‚úÖ Key points:
* Must have the same function signature.
* Base function must be `virtual`.
* Decided **at runtime** (dynamic dispatch).
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. Shallow Copy**
**Definition:**
A **shallow copy** copies **only the values of the member variables**.

* If a member is a **pointer**, it copies the pointer itself, **not the data it points to**.
* This means **both objects point to the same memory**.

**Problem:**
* If one object deletes/frees the memory, the other object‚Äôs pointer becomes **dangling**.
* Leads to **shared memory issues**, crashes, or undefined behavior.

**Example:**

```cpp
#include <iostream>
using namespace std;

class Shallow {
public:
    int* data;
    Shallow(int value) {
        data = new int(value);
    }
    ~Shallow() {
        delete data;
    }
};

int main() {
    Shallow obj1(10);
    Shallow obj2 = obj1;  // Shallow copy (default copy constructor)
    
    cout << *obj1.data << " " << *obj2.data << endl; // Both point to same memory

    obj2.data = new int(20); // Modifying obj2
    cout << *obj1.data << endl; // Could be unexpected if obj2 deleted memory
}
```

* Default copy constructor **does a shallow copy**.
* Both `obj1` and `obj2` share the same memory initially.

### **2. Deep Copy**
**Definition:**
A **deep copy** copies **the actual data** the pointer is pointing to, not just the pointer.
* Each object has its **own separate copy of the data**.
* Changes in one object **don‚Äôt affect** the other.

**Example:**

```cpp
#include <iostream>
using namespace std;

class Deep {
public:
    int* data;
    Deep(int value) {
        data = new int(value);
    }
    // Custom copy constructor for deep copy
    Deep(const Deep& other) {
        data = new int(*other.data); // Allocate new memory and copy value
    }
    ~Deep() {
        delete data;
    }
};

int main() {
    Deep obj1(10);
    Deep obj2 = obj1;  // Deep copy

    *obj2.data = 20;   // Modifying obj2 does NOT affect obj1
    cout << *obj1.data << " " << *obj2.data << endl; // 10 20
}

‚úÖ Key points:
* Deep copy is **safer** when using dynamic memory.
* You usually implement it by writing a **custom copy constructor** (and assignment operator if needed).

üí° Analogy:
Shallow copy ‚Üí Two people sharing the same notebook. //Shares the same memory
Deep copy ‚Üí Two people having their own copies of the notebook. //Each object has its own memory

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

### **1. What is a Constructor Initializer List?**
When you write a constructor like this:

```cpp
class A {
    int x;
public:
    A(int v) : x(v) {   // ‚Üê initializer list
        // constructor body
    }
};

That `: x(v)` part is called the **constructor initializer list**.
It means:
‚û°Ô∏è ‚ÄúBefore entering the constructor‚Äôs body, initialize member `x` with the value `v`.‚Äù

### **3. When it‚Äôs REQUIRED**
You *must* use an initializer list when:
* The class has a `const` member.
* The class has a reference (`&`) member.
* The class has a base class that requires parameters for its constructor.

**Example:**
```cpp
class A {
    const int x;
    int& ref;
public:
    A(int v, int& r) : x(v), ref(r) {} // Must use initializer list
};

If you try to assign inside the body instead, it won‚Äôt compile!
### **5. Example with Base Class**
```cpp
class Base {
public:
    Base(int a) { cout << "Base: " << a << endl; }
};

class Derived : public Base {
    int b;
public:
    Derived(int x, int y) : Base(x), b(y) {  // Call base constructor first
        cout << "Derived: " << b << endl;
    }
};

Output:
Base: 5
Derived: 10

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Polymorphism ‚Äî ‚ÄúMany Forms‚Äù**
**Meaning:**
Polymorphism allows **one interface (a base pointer/reference)** to represent **different actual types (derived objects)**, and to call the **right function automatically at runtime**.

### **1. Without Polymorphism (static binding)**

Let‚Äôs start simple:
```cpp
class Shape {
public:
    void draw() { cout << "Drawing Shape\n"; }
};

class Circle : public Shape {
public:
    void draw() { cout << "Drawing Circle\n"; }
};

int main() {
    Shape* s = new Circle();
    s->draw();   // ‚ùå Calls Shape::draw(), not Circle::draw()
}
```

Why?
Because by default, C++ looks at the **type of the pointer (`Shape*`)** ‚Äî not what it actually points to (`Circle`).
This is called **static binding** (decided at compile time).

### **2. With Polymorphism (dynamic binding)**

Now, make the base function **virtual** üëá

```cpp
class Shape {
public:
    virtual void draw() { cout << "Drawing Shape\n"; }
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
};

int main() {
    Shape* s = new Circle();
    s->draw();   // ‚úÖ Calls Circle::draw()
}

Now, `draw()` is **virtual**, so C++ looks at the **actual object type (Circle)** at runtime ‚Äî not just the pointer type.
This is called **dynamic dispatch** or **runtime polymorphism**.


### **3. Why it‚Äôs useful**
It lets you write **generic code** that works with different derived classes:

```cpp
void render(Shape* s) {
    s->draw();  // Calls the correct version automatically
}

```cpp
Circle c;
Square sq;
render(&c);   // ‚Üí Drawing Circle
render(&sq);  // ‚Üí Drawing Square

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Pure Virtual Function**

### **Definition:**

A **pure virtual function** is a virtual function that has **no implementation in the base class** ‚Äî it only defines the **interface (what should be done)**, not **how it‚Äôs done**.

You declare it by assigning `= 0` in the base class:

```cpp
class A {
public:
    virtual void f() = 0;  // Pure virtual function
};
```

This tells the compiler:

> ‚ÄúAny derived class **must** override `f()` ‚Äî I‚Äôm not providing an implementation here.‚Äù

## üß± **1. Abstract Class**

A class that has **at least one pure virtual function** becomes an **abstract class**.

```cpp
class A {
public:
    virtual void f() = 0; // pure virtual
};
You **cannot** create objects of an abstract class:

```cpp
A a;       // ‚ùå Error: cannot instantiate abstract class
A* ptr;    // ‚úÖ pointer is fine
```

You can only **derive from it** and implement the missing function.

## üß© **2. Derived Class Implements It**
```cpp
class A {
public:
    virtual void f() = 0; // pure virtual
};

class B : public A {
public:
    void f() override { cout << "Implemented in B\n"; }
};

int main() {
    B b;
    A* ptr = &b;
    ptr->f();  // ‚úÖ Calls B's version
}

Output:
Implemented in B

Now class `B` is **concrete** because it implements all pure virtual functions from `A`.

## üîç **3. Why use it?**

To create a **common interface** (like an abstract ‚Äúblueprint‚Äù) for derived classes.

Example:

```cpp
class Shape {
public:
    virtual void draw() = 0;     // Must be defined by derived
    virtual double area() = 0;   // Must be defined by derived
};
```

Derived classes must implement both:

```cpp
class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle\n"; }
    double area() override { return 3.14 * r * r; }
private:
    double r = 5;
};

Now `Shape` defines **what** shapes can do (`draw()`, `area()`),
and `Circle`, `Rectangle`, etc. define **how** they do it.


‚úÖ **In short:**
> A pure virtual function is a virtual function declared with `=0`, making the class abstract and forcing derived classes to implement it.
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **malloc/free vs new/delete**

Both are used to **allocate and free memory**,
but they behave **very differently** in C++.

### **1. malloc / free**  ‚Üí from **C language**
```cpp
int* p = (int*) malloc(sizeof(int));  // allocates raw memory
*p = 10;
free(p);                              // frees memory


* ‚úÖ Allocates **raw bytes** of memory.
* ‚ùå Does **NOT** call constructors or destructors.
* ‚ùå Doesn‚Äôt know about object types ‚Äî just bytes.
* ‚úÖ Must be matched with `free()`.
* ‚ö†Ô∏è Must use **manual casting** (because malloc returns `void*`).

Think of it as **low-level memory allocation** ‚Äî you just get a ‚Äúchunk‚Äù of memory.

### **2. new / delete**  ‚Üí from **C++**

```cpp
int* p = new int(10);  // allocate + initialize
delete p;              // destroy + free
```

* ‚úÖ Allocates memory **and calls the constructor**.
* ‚úÖ `delete` calls the **destructor** and then frees memory.
* ‚úÖ Type-safe ‚Äî returns the correct pointer type (no cast).
* ‚úÖ Cleaner, safer syntax.

---

### **3. For Objects**

Let‚Äôs see the real difference:

```cpp
class A {
public:
    A() { cout << "Constructor called\n"; }
    ~A() { cout << "Destructor called\n"; }
};

int main() {
    A* p1 = (A*) malloc(sizeof(A));  // no constructor
    free(p1);                        // no destructor

    A* p2 = new A();                 // constructor called
    delete p2;                       // destructor called
}
```

**Output:**
Constructor called
Destructor called

‚Üí The `malloc/free` pair never calls these functions ‚Äî so `A` is never ‚Äúfully constructed‚Äù or ‚Äúproperly destroyed.‚Äù

That can cause leaks or undefined behavior for complex classes.

### **4. Arrays**
| Operation   | For single object                  | For arrays |
| ----------- | ---------------------------------- | ---------- |
| Allocate    | `new A`                            | `new A[n]` |
| Free        | `delete`                           | `delete[]` |
| malloc/free | same for both ‚Äî no array awareness |            |

```cpp
A* arr = new A[5];  // calls constructor 5 times
delete[] arr;       // calls destructor 5 times

With `malloc/free`, none of that happens ‚Äî you just get bytes.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Struct vs Class in C++**
In C++, `struct` and `class` are **almost identical** ‚Äî the **only real difference** is their **default access levels**.
### **1. Default Access Levels**

| Member Type  | In `struct`                       | In `class`                         |
| ------------ | --------------------------------- | ---------------------------------- |
| Data members | **public** by default             | **private** by default             |
| Base classes | **public** inheritance by default | **private** inheritance by default |

```cpp
struct S {
    int x;          // public by default
};

class C {
    int x;          // private by default
};

So:
```cpp
S s;
s.x = 5;   // ‚úÖ OK (public)

C c;
c.x = 5;   // ‚ùå Error (private)

### **2. Otherwise, They‚Äôre the Same**
Both can have:
* Constructors, destructors
* Member functions
* Inheritance
* Virtual functions
* Operator overloading
* Access specifiers (`public`, `private`, `protected`)

Example:
```cpp
struct Point {
    int x, y;
    void show() { cout << x << ", " << y << endl; }
};
is functionally the same as:

```cpp
class Point {
public:
    int x, y;
    void show() { cout << x << ", " << y << endl; }
};

‚úÖ **In short:**
> In C++, `struct` and `class` are the same except:
> * `struct` members are **public by default**
> * `class` members are **private by default**

Even though a `struct` defaults to `public`, you can still explicitly use `private:` (or `protected:`) sections ‚Äî just like in a `class`.
### **Example:**

```cpp
#include <iostream>
using namespace std;

struct Person {
private:
    string name;  // private member

public:
    int age;      // public member

    void setName(string n) { name = n; }
    void show() { cout << name << " (" << age << ")\n"; }
};

int main() {
    Person p;
    p.age = 25;           // ‚úÖ allowed (public)
    // p.name = "John";   // ‚ùå not allowed (private)
    p.setName("John");    // ‚úÖ allowed (access through public function)
    p.show();
}

**Output:**
John (25)

### üß† Key Idea

Even though:

```cpp
struct Person { ... };
```

defaults to **public**,
you can still **control access** inside it using:

```cpp
private:
protected:
public:

Just like in a class!

### **In short:**

> ‚úÖ You can use `private:` and `protected:` inside a `struct`.
> The only difference from `class` is the **default** ‚Äî not the **capabilities**.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Exception Handling in C++**
### **1. The Basic Idea**

Exception handling lets you **detect errors (exceptions)** and **respond** to them **without crashing the program**.
It uses **three keywords**:
* `try` ‚Üí Code that might throw an error
* `throw` ‚Üí Signal (raise) the error
* `catch` ‚Üí Handle (catch) the error

### **2. Example Explained**
```cpp
#include <iostream>
#include <stdexcept>  // for runtime_error
using namespace std;

int main() {
    try {
        throw runtime_error("Err");  // üî• throw an exception
    } 
    catch (exception& e) {           // üßØ catch it
        cout << e.what();            // print what() message
    }
}

**Output:**
Err
### **3. Step-by-Step Breakdown**

| Step                          | What happens                                                                                         |
| ----------------------------- | ---------------------------------------------------------------------------------------------------- |
| `try { ... }`                 | You wrap code that might fail.                                                                       |
| `throw runtime_error("Err");` | You *throw* an exception object. This immediately stops normal flow and jumps to a matching `catch`. |
| `catch (exception& e)`        | The program finds this handler (since `runtime_error` is a kind of `exception`).                     |
| `e.what()`                    | Returns the error message (`"Err"`).                                                                 |

### **4. Common Exception Types (in `<stdexcept>`)**

| Exception type          | Meaning                               |
| ----------------------- | ------------------------------------- |
| `std::runtime_error`    | Error at runtime (like invalid state) |
| `std::logic_error`      | Error in program logic                |
| `std::out_of_range`     | Index out of range                    |
| `std::invalid_argument` | Bad function argument                 |
| `std::bad_alloc`        | Memory allocation failed              |

### **5. Multiple Catch Blocks**
You can handle different types differently:
```cpp
try {
    throw out_of_range("Index too big");
}
catch (out_of_range& e) {
    cout << "Range error: " << e.what();
}
catch (exception& e) {
    cout << "General error: " << e.what();
}

### **6. `catch(...)` for Anything**
You can also catch **any** type of exception:
```cpp
try {
    throw 123;  // could be anything
}
catch (...) {
    cout << "Caught something!\n";
}

### **7. Key Takeaways**
| Keyword    | Meaning                          |
| ---------- | -------------------------------- |
| `try`      | Wrap risky code                  |
| `throw`    | Raise an exception               |
| `catch`    | Handle an exception              |
| `e.what()` | Returns message inside exception |

üí° **In short:**
> `try` runs code that may fail ‚Üí
> `throw` raises an error ‚Üí
> `catch` handles it safely.

Perfect üëç ‚Äî let‚Äôs look at a **realistic example** of C++ exception handling with **`std::string`** or **string-related operations**.
## üß© **Example 1: String Index Out of Range**
```cpp
#include <iostream>
#include <string>
#include <stdexcept>  // for out_of_range
using namespace std;

int main() {
    string str = "hello";

    try {
        cout << "Character: " << str.at(10) << endl;  // out of range //`str.at(10)` means **‚Äúgive me the character at index 10 of the string `str`.‚Äù*
                    //Since `str = "hello"` has only 5 characters (`indexes 0‚Äì4`), index `10` is **out of range**, so it **throws an exception** (`std::out_of_range`)
    } 
    catch (out_of_range& e) {
        cout << "Caught exception: " << e.what() << endl;
    }

    cout << "Program continues normally.\n";
}

### **Output:**
Caught exception: basic_string::at: __n (which is 10) >= this->size() (which is 5)
Program continues normally.

## üß© **Example 2: Converting String to Integer**
Sometimes invalid input can cause an exception.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string input = "abc"; // not a valid number
    try {
        int num = stoi(input); // will throw invalid_argument
        cout << "Number: " << num << endl;
    } 
    catch (invalid_argument& e) {
        cout << "Invalid input: " << e.what() << endl;
    } 
    catch (out_of_range& e) {
        cout << "Number too large: " << e.what() << endl;
    }

    cout << "Program still running fine!\n";
}
stoi only converts strings that actually represent integers.
"123" ‚Üí 123 ‚úÖ
"12abc" ‚Üí throws invalid_argument because parsing stops at first invalid character.
"999999999999999999999999" ‚Üí throws out_of_range because number exceeds int limit.

### **Output:**
Invalid input: stoi
Program still running fine!

## üß© **Example 3: Throwing Your Own Exception**
You can also create your own checks and throw manually:
```cpp
#include <iostream>
#include <stdexcept>
#include <string>
using namespace std;

double divide(int a, int b) {
    if (b == 0)
        throw runtime_error("Division by zero!"); // manually throw
    return static_cast<double>(a) / b;
}

int main() {
    try {
        cout << divide(10, 0) << endl;
    } 
    catch (runtime_error& e) {
        cout << "Error: " << e.what() << endl;
    }
}

### **Output:**
Error: Division by zero!

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Smart Pointers ‚Äî Automatic Memory Management**

In old C++, you had to manually manage memory with `new` and `delete`:
```cpp
int* p = new int(5);
delete p;  // if you forget this ‚Üí memory leak!
```
‚úÖ **Smart pointers** solve this by **automatically deleting memory** when it‚Äôs no longer needed.
They live in the `<memory>` header.

## üí° **1. `unique_ptr` (Exclusive ownership)**
Only **one smart pointer** can own a resource at a time.

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> p1 = make_unique<int>(10);
    cout << *p1 << endl; // 10

    // unique_ptr<int> p2 = p1; ‚ùå Error ‚Äî cannot copy (only one owner)
    unique_ptr<int> p2 = move(p1); // ‚úÖ ownership transferred

    if (!p1) cout << "p1 is now empty\n";
}

**Output:**
10
p1 is now empty

‚úÖ Automatically frees memory when `p2` goes out of scope.
‚Üí Great for ownership ‚Äî no accidental copies, no leaks.

## üí° **2. `shared_ptr` (Shared ownership)**
Multiple pointers can share the same object.
The object is deleted **only when the last one is destroyed.**

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> p1 = make_shared<int>(42);
    shared_ptr<int> p2 = p1;  // share ownership

    cout << *p1 << ", " << *p2 << endl;
    cout << "Count: " << p1.use_count() << endl; // how many share it
}
**Output:**
42, 42
Count: 2

‚úÖ Automatically deletes memory when count ‚Üí 0.
‚Üí Great for shared resources.

## üí° **3. `weak_ptr` (Non-owning reference)**

Used with `shared_ptr` to **avoid circular references**.
It does **not** increase the reference count. only act as an observer

A weak_ptr does not keep the object alive.
It lets you observe or access the object only if it still exists.
You can safely check this with wp.lock():
Returns a valid shared_ptr ‚Üí object exists
Returns nullptr ‚Üí object has been deleted
So yes, you mainly use weak_ptr to:
Avoid circular references (prevent memory leaks)
Check if an object is still alive before accessing it

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> p1 = make_shared<int>(100);
    weak_ptr<int> wp = p1; // weak reference

    cout << "Count: " << p1.use_count() << endl; // 1

    if (auto sp = w.lock()) {
      cout << *sp << endl; // won‚Äôt execute, object deleted
    } else {
        cout << "Object no longer exists!" << endl; // safe check
    }
}

‚úÖ Doesn‚Äôt keep the object alive ‚Äî safe to check if it still exists.

## üí° **In short:**
> üîπ `unique_ptr` ‚Üí One owner.
> üîπ `shared_ptr` ‚Üí Many owners.
> üîπ `weak_ptr` ‚Üí Observes shared object without owning it.
>
> All of them **automatically free memory**, preventing leaks.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## üß© **Multithreading Basics in C++11**
**Multithreading** allows your program to run **multiple functions at the same time** (concurrently) using CPU cores efficiently.
### **1. Creating a Thread**

```cpp
#include <iostream>
#include <thread>
using namespace std;

void work() {
    cout << "Hello from thread!" << endl;
}

int main() {
    thread t(work); // create a thread that runs 'work' concurrently
    t.join();       // wait for thread to finish
    cout << "Main thread done!" << endl;
}

**Output:**
Hello from thread!
Main thread done!

‚úÖ `thread t(work);` ‚Üí starts a **new thread** running the function `work`.
‚úÖ `t.join();` ‚Üí main thread waits for this thread to finish.


### **2. Key Points**
| Keyword      | Meaning                                       |
| ------------ | --------------------------------------------- |
| `thread`     | Class representing a thread of execution      |
| `t.join()`   | Waits for the thread to finish (blocking)     |
| `t.detach()` | Let thread run independently (no join needed) |

### **3. Passing Arguments**
```cpp
void printNumber(int x) {
    cout << "Number: " << x << endl;
}

int main() {
    thread t(printNumber, 42); // pass argument to thread function
    t.join();
}
Output:
Number: 42

### **4. Simple Analogy**

* Main thread = your program‚Äôs main ‚Äúperson‚Äù.
* New thread = an assistant doing some work **at the same time**.
* `join()` = wait for the assistant to finish before moving on.

### ‚úÖ **In short:**
> `thread t(work);` ‚Üí runs `work()` **concurrently**.
> `t.join();` ‚Üí waits for the thread to finish before continuing.

## **1. Thread Basics (you already know)**
* `std::thread` ‚Äî create a thread.
* `t.join()` vs `t.detach()`.
* Passing arguments to threads (`thread t(func, arg1, arg2);`).

## **2. Shared Data & Synchronization**
### **Problem**
Multiple threads modifying the same variable can cause **data races**, which is undefined behavior.

```cpp
#include <iostream>
#include <thread>

int counter = 0;

void increment() {
    for(int i = 0; i < 1000; ++i) counter++;
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << counter << "\n";  // Usually not 2000! ‚ùå
}
```

‚úÖ **Why?** Threads can read/write simultaneously ‚Üí race condition.

---

### **Solution: `std::mutex`**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int counter = 0;
mutex mtx;

void increment() {
    for(int i = 0; i < 1000; ++i) {
        lock_guard<mutex> lock(mtx); // automatically locks/unlocks
        counter++;
    }
}

int main() {
    thread t1(increment);
    thread t2(increment);
    t1.join();
    t2.join();
    cout << counter << endl; // ‚úÖ always 2000
}

* `mutex` = mutual exclusion, prevents simultaneous access.
* `lock_guard` = RAII style lock (preferred).

## **3. Atomic Variables**
For simple counters, `std::atomic` can be faster than a mutex:

```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<int> counter(0);

void increment() {
    for(int i=0; i<1000; ++i) counter++;
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << counter << std::endl; // ‚úÖ always 2000
}

## **4. Condition Variables**
Used for **thread coordination** (producer-consumer style).

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
using namespace std;

queue<int> q;
mutex mtx;
condition_variable cv;

void producer() {
    for(int i=1;i<=5;i++){
        unique_lock<mutex> lock(mtx);
        q.push(i);
        cv.notify_one(); // wake up consumer
    }
}

void consumer() {
    for(int i=1;i<=5;i++){
        unique_lock<mutex> lock(mtx);
       // cv.wait(lock, []{ return !q.empty(); }); // wait until producer adds something
       while (q.empty()){
          cv.wait(lock);
       }
        cout << "Consumed: " << q.front() << endl;
        q.pop();
    }
}

int main() {
    thread t1(producer), t2(consumer);
    t1.join();
    t2.join();
}

## **5. Strings and Thread Safety**

* **`std::string` is NOT thread-safe** for simultaneous writes.
* Reading a string from multiple threads is safe **if nobody modifies it**.
* Use `mutex` if multiple threads might modify the same string.

#include <iostream>
#include <string>
#include <thread>
#include <mutex>

std::string data = "Hello";
std::mutex mtx;

void appendData() {
    std::lock_guard<std::mutex> lock(mtx);  // <-- std:: added
    data += " World";
}

int main() {
    std::thread t1(appendData);
    std::thread t2(appendData);

    t1.join();
    t2.join();

    std::cout << data << std::endl;
}

Use lock_guard when you just need to protect a critical section.
Use unique_lock when you need more control (e.g. with condition_variable).

